/*//////////////////////////////////////////////////////////////
// main.c - An Entry Point Function for the Project
//
// Author: Himanshu Devi (hdevi@pdx.edu)
// Author: Sanika Balkawade (sanika@pdx.edu)
// Date: 02/20/2018
//
// Description:
// ------------
// Implemented Entry point function (main) which initializes Platform
// and all Peripherals such as PmodENC, PmodOLEDrgb, AXI Timer, GPIO Ports,
// Connects Interrupts to Interrupt Controller.
// There are in all Four Tasks:
// 1.MasterTask--Creates all Tasks,Semaphores and Queues
// 2.readparametersTask--Takes the Semaphore from PERIPHERAL_Handler and reads buttons,switches and Rotary cnt.
// 3.displayTask--Receives the input from queue and displays it on OLED_rgb
// 4.PIDControlTask--Receives the input from queue and implements the PID control logic
// 5.PERIPHERAL_Handler--called when interrupt occurs and Releases Semaphore.
// 6.PULSECOUNT_Handler--called when interrupt occurs at the GPIO pin for pulse generated by Hall sensor
// 7.SECONDS_Handler--called after 1 sec which takes the count value from PULSECOUNT_Handler
// 8.WATCHDOG_Handler--called when timeout occurs
////////////////////////////////////////////////////////////////*/
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include "platform.h"
#include "xparameters.h"
#include "xstatus.h"
#include "microblaze_sleep.h"
#include "PmodOLEDrgb.h"
#include "PmodENC.h"
#include "xgpio.h"
#include "xintc.h"
#include "pwm_tmrctr.h"
#include "xtmrctr.h"
#include "xil_printf.h"
#include <math.h>
#include "stdbool.h"
#include "xwdttb.h"

/* FreeRTOS includes. */
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "timers.h"
#include "semphr.h"

// Clock frequencies
#define CPU_CLOCK_FREQ_HZ        XPAR_CPU_CORE_CLOCK_FREQ_HZ
#define AXI_CLOCK_FREQ_HZ        XPAR_CPU_M_AXI_DP_FREQ_HZ

// AXI timer parameters
#define AXI_TIMER_0_DEVICE_ID     XPAR_AXI_TIMER_0_DEVICE_ID
#define AXI_TIMER_0_BASEADDR      XPAR_AXI_TIMER_0_BASEADDR
#define AXI_TIMER_0_HIGHADDR 	  XPAR_AXI_TIMER_0_HIGHADDR

#define AXI_TIMER_1_DEVICE_ID     XPAR_AXI_TIMER_1_DEVICE_ID
#define AXI_TIMER_1_BASEADDR      XPAR_AXI_TIMER_1_BASEADDR
#define AXI_TIMER_1_HIGHADDR 	  XPAR_AXI_TIMER_1_HIGHADDR

#define AXI_TIMER_2_DEVICE_ID     XPAR_AXI_TIMER_2_DEVICE_ID
#define AXI_TIMER_2_BASEADDR      XPAR_AXI_TIMER_2_BASEADDR
#define AXI_TIMER_2_HIGHADDR 	  XPAR_AXI_TIMER_2_HIGHADDR

// GPIO parameters
#define GPIO_SWBUT_DEVICE_ID		XPAR_AXI_GPIO_0_DEVICE_ID
#define GPIO_BUT_INPUT_CHANNEL		1
#define GPIO_SW_INPUT_CHANNEL		2
#define SWITCHES_ENABLE_MASK 		0xffff

#define GPIO_LED_DEVICE_ID		    XPAR_AXI_GPIO_1_DEVICE_ID
#define GPIO_LED_OUTPUT_CHANNEL		1

#define GPIO_DIRSEN_DEVICE_ID		XPAR_AXI_GPIO_2_DEVICE_ID
#define GPIO_DIR_OUTPUT_CHANNEL		1
#define GPIO_SEN_INPUT_CHANNEL		2

// OLEDrgb parameters
#define RGBDSPLY_DEVICE_ID        XPAR_PMODOLEDRGB_0_DEVICE_ID
#define RGBDSPLY_GPIO_BASEADDR    XPAR_PMODOLEDRGB_0_AXI_LITE_GPIO_BASEADDR
#define RGBDSPLY_GPIO_HIGHADDR    XPAR_PMODOLEDRGB_0_AXI_LITE_GPIO_HIGHADD
#define RGBDSPLY_SPI_BASEADDR     XPAR_PMODOLEDRGB_0_AXI_LITE_SPI_BASEADDR
#define RGBDSPLY_SPI_HIGHADDR     XPAR_PMODOLEDRGB_0_AXI_LITE_SPI_HIGHADDR

// PmodENC parameters
#define PMODENC_DEVICE_ID         XPAR_PMODENC_0_DEVICE_ID
#define PMODENC_BASEADDR          XPAR_PMODENC_0_S00_AXI_BASEADDR
#define PMODENC_HIGHADDR          XPAR_PMODENC_0_S00_AXI_HIGHADDR

// Interrupt Controller parameters
#define INTC_DEVICE_ID			XPAR_INTC_0_DEVICE_ID
#define FIT_INTERRUPT_ID		XPAR_MICROBLAZE_0_AXI_INTC_FIT_TIMER_0_INTERRUPT_INTR
#define GPIO_SWBUT_INTERRUPT_ID		XPAR_MICROBLAZE_0_AXI_INTC_AXI_GPIO_0_IP2INTC_IRPT_INTR
#define GPIO_SEN_INTERRUPT_ID		XPAR_MICROBLAZE_0_AXI_INTC_AXI_GPIO_2_IP2INTC_IRPT_INTR
#define AXI_TIMER_2_INTERRUPT_ID	XPAR_MICROBLAZE_0_AXI_INTC_AXI_TIMER_2_INTERRUPT_INTR
#define AXI_TIMER_1_INTERRUPT_ID	XPAR_MICROBLAZE_0_AXI_INTC_AXI_TIMER_1_INTERRUPT_INTR
#define WATCHDOG_TIMER_ID		XPAR_MICROBLAZE_0_AXI_INTC_AXI_TIMEBASE_WDT_0_WDT_INTERRUPT_INTR

// WatchDOG Timer parameters
#define WATCHDOG_DEVICE_ID		XPAR_WDTTB_0_DEVICE_ID
#define WATCHDOG_BASE_ADDR		XPAR_WDTTB_0_BASEADDR
#define WATCHDOG_HIGH_ADDR		XPAR_WDTTB_0_HIGHADDR
#define WATCHDOG_WND_TIMEOUT		XPAR_WDTTB_0_ENABLE_WINDOW_WDT
#define WATCHDOG_MAX_CNT		XPAR_WDTTB_0_MAX_COUNT_WIDTH

#define TmrCtrNumber            0
#define TmrCtrNumber1            0
#define TmrCtrNumber2           0

// Microblaze peripheral instances
XTmrCtr        AXITimerInst;
XTmrCtr        AXITimerInst1;
XTmrCtr        AXITimerInst2;
PmodOLEDrgb    pmodOLEDrgb_inst;
PmodENC        pmodENC_inst;
XIntc 	       IntrptCtlrInst;
XGpio	       MOTORSENSOR_inst;
XGpio 	       LED_inst;
XGpio 	       SWITCHBUTTON_inst;
XWdtTb	       WTD_inst;

//Enumeration for Buttons
enum _GPIO_btns {BTNR, BTNL, BTND, BTNU, BTNC};

//DIR outputs
#define GPIO_SET_DIR_CLK				0
#define GPIO_SET_DIR_CNTCLK				1

//LED mask
#define GPIO_LED_MASK			0x0000FFFF


//Push Button Masks
#define GPIO_BTNR_MASK 			8
#define GPIO_BTNL_MASK			4
#define GPIO_BTND_MASK			16
#define GPIO_BTNU_MASK			2
#define GPIO_BTNC_MASK			1
#define GPIO_ALLBTNS_MASK		31

//Switches masks
#define	SWITCHES_5_4 0x0030
#define	SWITCHES_3_2 0xc
#define	SWITCHES_1_0 0x0003

//Macros for switches
#define	SELECT_KP	0
#define	SELECT_KI	1
#define	SELECT_KD	2

#define	INCDEC_BY_1	0
#define	INCDEC_BY_5	1
#define	INCDEC_BY_10	2

#define KP_SETLED			1
#define KI_SETLED			2
#define KD_SETLED			4

#define TIMER_ID	1
#define DELAY_10_SECONDS	10000UL
#define DELAY_1_SECOND		1000UL
#define TIMER_CHECK_THRESHOLD	9

//DIR outputs
#define GPIO_SET_DIR_0				1

//LED mask
#define GPIO_LED_MASK			0x0000FFFF


//Push Button Masks
#define GPIO_BTNR_MASK 			8
#define GPIO_BTNL_MASK			4
#define GPIO_BTND_MASK			16
#define GPIO_BTNU_MASK			2
#define GPIO_BTNC_MASK			1
#define GPIO_ALLBTNS_MASK		31

//Switches masks
#define	SWITCHES_5_4 0x0030
#define	SWITCHES_3_2 0xc
#define	SWITCHES_1_0 0x0003
#define SWITCHES_15  0x8000

//Macros for switches
#define	SELECT_KP	0
#define	SELECT_KI	1
#define	SELECT_KD	2

#define	INCDEC_BY_1	0
#define	INCDEC_BY_5	1
#define	INCDEC_BY_10	2

#define	SPEED_BY_1	1
#define	SPEED_BY_5	5
#define	SPEED_BY_10	10

#define KP_SETLED			1
#define KI_SETLED			2
#define KD_SETLED			4

#define TIMER_ID		1
#define DELAY_10_SECONDS	10000UL
#define DELAY_1_SECOND		1000UL
#define TIMER_CHECK_THRESHOLD	9


volatile unsigned char PID_MAGNITUDE, PID_SELECT, MOTOR_MAGNITUDE,CRASH;
volatile uint16_t switches;

//Handles for Task,Queue and Semaphore
static TaskHandle_t xdisplay;
static TaskHandle_t xreadParameter;
static TaskHandle_t xmaster;
static TaskHandle_t xpid;
//static TaskHandle_t xcontrol_motor_ip;
static QueueHandle_t xdisplayQueue;
static QueueHandle_t xoutputQueue;
static QueueHandle_t xpidQueue;
static SemaphoreHandle_t peripheral_sem;
static SemaphoreHandle_t pulse_sem;


//Function Declarations
int do_init(void);
int Initialize_GPIOS(void);
portBASE_TYPE Initiaize_INTERRUPTS();
int AXI_Timer_initialize(void);
int Initialize_PWM(void);
void PMDIO_putnum(PmodOLEDrgb* InstancePtr, int32_t num, int32_t radix);
void PMDIO_puthex(PmodOLEDrgb* InstancePtr, uint32_t num);
void PMDIO_itoa(int32_t value, char *string, int32_t radix);
int isbutton_pressed(enum _GPIO_btns btnslct);
unsigned short GET_SWITCHES(void);
void SET_LED(short unsigned int ledval);
static void displayTask(void *pvParameters);
static void readParametersTask(void *pvParameters);
static void PIDControlTask(void *pvParameters);
static void WATCHDOG_Handler(void* pvParameters);
static void PERIPHERAL_Handler(void* pvParameters);
static void PULSE_Handler(void* pvParameters);
static void SECONDS_Handler(void* pvParameters);
static void masterTask (void *pvParameters);


//Global Variables
volatile int count = 0, oldcount = 0,temp = 0;
volatile int readParametersTaskflag , displayTaskflag ,PIDControlTaskflag;
volatile int sys_running,Forcecrash;

//Structure Definitions
typedef struct
{
  volatile uint8_t kp,ki,kd,conv;
  volatile uint32_t duty_cycle,count;
  volatile int arpm,drpm;
}Parameters_t;

Parameters_t common_parameter;

int main()
{
  //Initialization of Platform
  init_platform();

  uint32_t sts;
  //Initialize the System and Peripherals
  sts = do_init();
  if (XST_SUCCESS != sts)
    {
      xil_printf(" System Initialization failed\n");
      exit(1);
    }

  microblaze_enable_interrupts();

  if(XWdtTb_IsWdtExpired(&WTD_inst))
    {
      do{
	  xil_printf("Watch Dog Timer Expired\n");
      }while(sys_running == 0);
    }

  //Creation of Master Thread
  xTaskCreate(masterTask,
	      (const char *)"Master",
	      configMINIMAL_STACK_SIZE,
	      NULL,
	      tskIDLE_PRIORITY,
	      &xmaster);

  //Start FreeRTOS
  vTaskStartScheduler();

  //Cleanup Platform
  cleanup_platform();

  return 0;

}

//Watchdog Handler
static void WATCHDOG_Handler(void* pvParameters)
{
  if((sys_running == 1 ) && (Forcecrash == 0))
    XWdtTb_RestartWdt(&WTD_inst);
  else
    xil_printf("Oops......SYSTEM CRASHED\n");

  XWdtTb_IntrClear(&WTD_inst);
}

//Handler called when buttons or switches interrupt occurs, Semaphore is released
static void PERIPHERAL_Handler(void* pvParameters)
{
  xSemaphoreGiveFromISR(peripheral_sem,NULL);

  XGpio_InterruptClear(&SWITCHBUTTON_inst, SWITCHES_ENABLE_MASK);
}

//handler to take pulse count
static void PULSE_Handler(void* pvParameters)
{
  if(XGpio_DiscreteRead(&MOTORSENSOR_inst,GPIO_SEN_INPUT_CHANNEL) == 1)
    {
      common_parameter.count++;

    }

  XGpio_InterruptClear(&MOTORSENSOR_inst, 0xffff );
}

//Handler to take take count readings after 1 sec
static void SECONDS_Handler(void* pvParameters)
{
  u32		ctlsts2;
  ctlsts2 = XTmrCtr_GetControlStatusReg(AXI_TIMER_2_BASEADDR, TmrCtrNumber2);
  ctlsts2 |= XTC_CSR_INT_OCCURED_MASK;
  XTmrCtr_SetControlStatusReg(AXI_TIMER_2_BASEADDR, TmrCtrNumber2, ctlsts2);

  if(oldcount != common_parameter.count)
    {
      common_parameter.arpm = common_parameter.count * 60;

      oldcount = common_parameter.count;
    }


  common_parameter.count = 0;

}

//Master task used to initialize Semaphores, Tasks and message Queues
void masterTask (void *pvParameters)
{
  //Create Semaphores
  peripheral_sem = xSemaphoreCreateBinary();
  if (peripheral_sem == NULL)
    {
      xil_printf ("Insufficient Heap Memory\n");
      exit (1);
    }

  xil_printf("Semaphore Created\n");

  //Create Message Queues
  xdisplayQueue = xQueueCreate(1, sizeof(Parameters_t));
  /* Check the queue was created. */
  configASSERT(xdisplayQueue);

  //Create Message Queues
  xoutputQueue = xQueueCreate(1, sizeof(Parameters_t));
  /* Check the queue was created. */
  configASSERT(xoutputQueue);

  //Create Message Queues
  xpidQueue = xQueueCreate(1, sizeof(Parameters_t));
  /* Check the queue was created. */
  configASSERT(xpidQueue);



  xTaskCreate (readParametersTask,
	       (const char *) "Read",
	       2048,
	       NULL,
	       tskIDLE_PRIORITY + 3,
	       &xreadParameter);

  xTaskCreate (displayTask,
	       (const char *) "Display",
	       2048,
	       NULL,
	       tskIDLE_PRIORITY + 3,
	       &xdisplay);

  xTaskCreate (PIDControlTask,
	       (const char *) "PID",
	       2048,
	       NULL,
	       tskIDLE_PRIORITY + 3,
	       &xpid);

XWdtTb_Start(&WTD_inst);

  while(1)
    {
      if(readParametersTaskflag && displayTaskflag && PIDControlTaskflag)
	sys_running = 1;
      else
	sys_running = 0;

      if(Forcecrash)
	sys_running = 0;

      readParametersTaskflag = 0;
      displayTaskflag = 0;
      PIDControlTaskflag = 0;
    }

  for(;;);

}

//Task to display the output on the OLED_rgb display
void displayTask(void* pvParameters)
{
  Parameters_t display_parameters,temp_parameters,output_parameter;
  while(1)
    {
      displayTaskflag = 1;
      xil_printf("DISPL DRPM:%d\n",display_parameters.drpm);
      //Receives parameters from xdisplayQueue
      xQueueReceive(xdisplayQueue,&display_parameters,100);
      //Receives parameters from xoutputQueue
      xQueueReceive(xoutputQueue,&output_parameter,100);
      if((display_parameters.conv != temp_parameters.conv))
	{
	  OLEDrgb_SetFontColor(&pmodOLEDrgb_inst,OLEDrgb_BuildRGB(70,130,180));
	  OLEDrgb_SetCursor(&pmodOLEDrgb_inst, 3, 0);
	  OLEDrgb_PutString(&pmodOLEDrgb_inst, "   ");
	  OLEDrgb_SetCursor(&pmodOLEDrgb_inst, 3, 0);
	  PMDIO_putnum(&pmodOLEDrgb_inst, display_parameters.conv, 10);
	}

      if((display_parameters.duty_cycle != temp_parameters.duty_cycle))
	{
	  OLEDrgb_SetCursor(&pmodOLEDrgb_inst, 9, 0);
	  OLEDrgb_PutString(&pmodOLEDrgb_inst, "   ");
	  OLEDrgb_SetCursor(&pmodOLEDrgb_inst, 9, 0);
	  PMDIO_putnum(&pmodOLEDrgb_inst, display_parameters.duty_cycle, 10);
	}
      if((display_parameters.kp != temp_parameters.kp))
	{
	  OLEDrgb_SetCursor(&pmodOLEDrgb_inst, 0, 4);
	  OLEDrgb_PutString(&pmodOLEDrgb_inst, "   ");
	  OLEDrgb_SetCursor(&pmodOLEDrgb_inst, 0, 4);
	  PMDIO_putnum(&pmodOLEDrgb_inst, display_parameters.kp, 10);
	}

      if((display_parameters.ki != temp_parameters.ki))
	{
	  OLEDrgb_SetCursor(&pmodOLEDrgb_inst, 4, 4);
	  OLEDrgb_PutString(&pmodOLEDrgb_inst, "   ");
	  OLEDrgb_SetCursor(&pmodOLEDrgb_inst, 4, 4);
	  PMDIO_putnum(&pmodOLEDrgb_inst, display_parameters.ki, 10);
	}

      if((display_parameters.kd != temp_parameters.kd))
	{
	  OLEDrgb_SetCursor(&pmodOLEDrgb_inst, 8, 4);
	  OLEDrgb_PutString(&pmodOLEDrgb_inst, "   ");
	  OLEDrgb_SetCursor(&pmodOLEDrgb_inst, 8, 4);
	  PMDIO_putnum(&pmodOLEDrgb_inst, display_parameters.kd, 10);
	}

	  OLEDrgb_SetCursor(&pmodOLEDrgb_inst, 5, 5);
	  OLEDrgb_PutString(&pmodOLEDrgb_inst, "         ");
	  OLEDrgb_SetCursor(&pmodOLEDrgb_inst, 5, 5);
	  PMDIO_putnum(&pmodOLEDrgb_inst,display_parameters.drpm, 10);

	  OLEDrgb_SetCursor(&pmodOLEDrgb_inst, 5, 7);
	  OLEDrgb_PutString(&pmodOLEDrgb_inst, "      ");
	  OLEDrgb_SetCursor(&pmodOLEDrgb_inst, 5, 7);
	  PMDIO_putnum(&pmodOLEDrgb_inst,output_parameter.arpm, 10);

      temp_parameters = display_parameters;
    }
}

//Reads parameters when semaphores is realized or else reads rotary count
void readParametersTask(void* pvParameters)
{
  Parameters_t motor_input_parameters = {0,0,0,0,0,0,0,0};
  uint16_t RotaryCnt,OldRotaryCnt = 0xFFFF;
  bool RotaryNoNeg = false;
  pmodENC_clear_count(&pmodENC_inst);

  while(1)
    {
      readParametersTaskflag = 1;
     //Reads the buttons or switches when Semaphore is realized or else reads Rotary cnt
      if(xSemaphoreTake(peripheral_sem,100))
	{
	  xil_printf("Semaphore Taken\n");
	  if(isbutton_pressed(BTNC))
	    {
	      xil_printf("EXIT\n");
	      motor_input_parameters.kp = 0;
	      motor_input_parameters.kd = 0;
	      motor_input_parameters.ki = 0;
	      motor_input_parameters.duty_cycle = 0;
	      pmodENC_clear_count(&pmodENC_inst);
	      RotaryCnt = 0;
	      PWM_SetParams(&AXITimerInst1, 4*10^3 ,0);
	    }
	  switches = GET_SWITCHES();
	  MOTOR_MAGNITUDE = (switches & SWITCHES_1_0);
	  PID_SELECT = (switches & SWITCHES_3_2) >> 2;
	  PID_MAGNITUDE = (switches & SWITCHES_5_4)>> 4;
	  CRASH = (switches & SWITCHES_15);
	  xil_printf("CRASH %d | %d | %d\n",CRASH,switches,SWITCHES_15);

	  //switch to select the motor magnitude
	  switch(MOTOR_MAGNITUDE)
	  {

	    case INCDEC_BY_1:
	      pmodENC_init(&pmodENC_inst, SPEED_BY_1, RotaryNoNeg);
	      break;
	    case INCDEC_BY_5:
	      pmodENC_init(&pmodENC_inst, SPEED_BY_5, RotaryNoNeg);
	      break;
	    case INCDEC_BY_10:
	      pmodENC_init(&pmodENC_inst, SPEED_BY_10, RotaryNoNeg);
	      break;
	  }

	  //Switch case to select the constant
	  switch(PID_SELECT)
	  {

	    case SELECT_KP:

	      SET_LED(KP_SETLED);
	      switch(PID_MAGNITUDE)
	      {
		case INCDEC_BY_1:
		  if(isbutton_pressed(BTNU))
		    motor_input_parameters.kp += 1;
		  if(isbutton_pressed(BTND))
		    motor_input_parameters.kp -= 1;
		  break;
		case INCDEC_BY_5:
		  if(isbutton_pressed(BTNU))
		    motor_input_parameters.kp += 5;
		  if(isbutton_pressed(BTND))
		    motor_input_parameters.kp -= 5;
		  break;
		case INCDEC_BY_10:
		  if(isbutton_pressed(BTNU))
		    motor_input_parameters.kp += 10;
		  if(isbutton_pressed(BTND))
		    motor_input_parameters.kp -= 10;
		  break;
		default:
		  if(isbutton_pressed(BTNU))
		    motor_input_parameters.kp += 10;
		  if(isbutton_pressed(BTND))
		    motor_input_parameters.kp -= 10;
		  break;
	      }
	      break;

		case SELECT_KI:

		  SET_LED(KI_SETLED);
		  switch(PID_MAGNITUDE)
		  {
		    case INCDEC_BY_1:
		      if(isbutton_pressed(BTNU))
			motor_input_parameters.ki += 1;
		      if(isbutton_pressed(BTND))
			motor_input_parameters.ki -= 1;
		      break;
		    case INCDEC_BY_5:
		      if(isbutton_pressed(BTNU))
			motor_input_parameters.ki += 5;
		      if(isbutton_pressed(BTND))
			motor_input_parameters.ki -= 5;
		      break;
		    case INCDEC_BY_10:
		      if(isbutton_pressed(BTNU))
			motor_input_parameters.ki += 10;
		      if(isbutton_pressed(BTND))
			motor_input_parameters.ki -= 10;
		      break;
		    default:
		      if(isbutton_pressed(BTNU))
			motor_input_parameters.ki += 10;
		      if(isbutton_pressed(BTND))
			motor_input_parameters.ki -= 10;
		      break;
		  }
		  break;


		    case SELECT_KD:

		      SET_LED(KD_SETLED);
		      switch(PID_MAGNITUDE)
		      {
			case INCDEC_BY_1:
			  if(isbutton_pressed(BTNU))
			    motor_input_parameters.kd += 1;
			  if(isbutton_pressed(BTND))
			    motor_input_parameters.kd -= 1;
			  break;
			case INCDEC_BY_5:
			  if(isbutton_pressed(BTNU))
			    motor_input_parameters.kd += 5;
			  if(isbutton_pressed(BTND))
			    motor_input_parameters.kd -= 5;
			  break;
			case INCDEC_BY_10:
			  if(isbutton_pressed(BTNU))
			    motor_input_parameters.kd += 10;
			  if(isbutton_pressed(BTND))
			    motor_input_parameters.kd -= 10;
			  break;
			default:
			  if(isbutton_pressed(BTNU))
			    motor_input_parameters.kd += 10;
			  if(isbutton_pressed(BTND))
			    motor_input_parameters.kd -= 10;
			  break;
		      }
		      break;

			default:

			  SET_LED(KD_SETLED);
			  switch(PID_MAGNITUDE)
			  {
			    case INCDEC_BY_1:
			      if(isbutton_pressed(BTNU))
				motor_input_parameters.kd += 1;
			      if(isbutton_pressed(BTND))
				motor_input_parameters.kd -= 1;
			      break;
			    case INCDEC_BY_5:
			      if(isbutton_pressed(BTNU))
				motor_input_parameters.kd += 5;
			      if(isbutton_pressed(BTND))
				motor_input_parameters.kd -= 5;
			      break;
			    case INCDEC_BY_10:
			      if(isbutton_pressed(BTNU))
				motor_input_parameters.kd += 10;
			      if(isbutton_pressed(BTND))
				motor_input_parameters.kd -= 10;
			      break;
			    default:
			      if(isbutton_pressed(BTNU))
				motor_input_parameters.kd += 10;
			      if(isbutton_pressed(BTND))
				motor_input_parameters.kd -= 10;
			      break;
			  }
			  break;
	  }

	  //Forcecrash when Switch 15 is pressed
	  if(XGpio_DiscreteRead(&SWITCHBUTTON_inst,GPIO_SW_INPUT_CHANNEL) == 0x8000)
	    {
	      Forcecrash = 1;
	    }

	}

      //Read Rotary Encoder
      else
	{

	  if(pmodENC_is_switch_on(&pmodENC_inst) == true)
	    {

	    XGpio_DiscreteWrite(&MOTORSENSOR_inst,GPIO_DIR_OUTPUT_CHANNEL,GPIO_SET_DIR_CLK);
	    }
	  else
	    {

	    XGpio_DiscreteWrite(&MOTORSENSOR_inst,GPIO_DIR_OUTPUT_CHANNEL,GPIO_SET_DIR_CNTCLK);
	    }


	  pmodENC_read_count(&pmodENC_inst,&RotaryCnt);
	  motor_input_parameters.conv = RotaryCnt;
	  if (RotaryCnt != OldRotaryCnt)
	    {
	      motor_input_parameters.duty_cycle = ((float)100/255) * motor_input_parameters.conv;
	      motor_input_parameters.drpm = motor_input_parameters.duty_cycle * 115;

	    }

	  OldRotaryCnt = RotaryCnt;

	}
      //send the parameters to xdisplayqueue and xpidqueue
      xQueueSend(xdisplayQueue,&motor_input_parameters,0UL);
      xQueueSend(xpidQueue,&motor_input_parameters,0UL);
    }
}

//Task to implement the PID logic
static void PIDControlTask(void *pvParameters)
{
  Parameters_t pid_parameters;
  volatile int OldError = 0,NewError = 0,IError = 0, DError = 0,Command = 0;
  uint32_t duty_cycle;
  XStatus status;
  while(1)
    {
      PIDControlTaskflag = 1;
      //receives input from xpidqueue
      xQueueReceive(xpidQueue,&pid_parameters,100);
      pid_parameters.arpm = common_parameter.arpm;

      NewError = pid_parameters.drpm - pid_parameters.arpm;

      //Integrating the previous error and current error and limiting the value to 5000
      IError += NewError;
      if(IError > 5000)
	IError = 5000;
      else if (IError < -5000)
	IError = -5000;
      else
	IError = IError;

      //calculating the differential error
      DError =  NewError - OldError;
      //multiplying the constants with the respective errors calculated
      Command = ((((float)pid_parameters.kp/100) * NewError) + (((float)pid_parameters.ki/100) * IError) + (((float)pid_parameters.kd) * DError));

      Command = (pid_parameters.drpm + Command);

      //limit the value of duty cycle so that it does not exceed the 100%
      duty_cycle = Command / 115;
      if(duty_cycle > 100)
	{
	  duty_cycle = 100;
	}
      else if(duty_cycle < 0)
	{
	  duty_cycle = 0;
	}
      else
	duty_cycle = duty_cycle;

      //setting the PWM to the calculated duty cycle at 4kHz
      status = PWM_SetParams(&AXITimerInst1, 4*10^3 ,duty_cycle);
      if(status != XST_SUCCESS)
	{
	  xil_printf("Failed to set PWM parameters\n");
	  exit(1);
	}
      OldError = NewError;
      //sSending the nex calculted parameters to the DisplayTask via xoutputqueue
      xQueueSend(xoutputQueue,&pid_parameters,0UL);
    }
}
/*****************************************Initialization***************************************/
int do_init()
{
  int status;
  portBASE_TYPE xStatus;

  // initialize the PMod544IO driver and the PmodENC and PmodCLP
  status = pmodENC_initialize(&pmodENC_inst, PMODENC_BASEADDR);
  if (status == XST_FAILURE)
    {
      xil_printf("ENC failed\n");
      return XST_FAILURE;
    }

  // Initialize the OLED display
  OLEDrgb_begin(&pmodOLEDrgb_inst, RGBDSPLY_GPIO_BASEADDR, RGBDSPLY_SPI_BASEADDR);

  status = Initialize_GPIOS();
  if (status == XST_FAILURE)
    {
      xil_printf("Oops....GPIO INITIALIZATION failed\n");
      return XST_FAILURE;
    }

  // Initialize the AXI Timer
  status = AXI_Timer_initialize();
  if (status != XST_SUCCESS)
    {
      xil_printf("Oops....AXI TIMER INITIALIZATION failed\n");
      return XST_FAILURE;
    }

  xStatus = Initiaize_INTERRUPTS();
  if (xStatus == pdFAIL)
    {
      xil_printf("Oops....INTERRUPTS INITIALIZATION failed\n");
      return XST_FAILURE;
    }

  status = Initialize_PWM();
  if (status != XST_SUCCESS)
    {
      xil_printf("GPIO 0 failed\n");
      return XST_FAILURE;
    }

  status = XWdtTb_Initialize(&WTD_inst,WATCHDOG_DEVICE_ID);
  if (status != XST_SUCCESS)
      {
        xil_printf("WATCHDOG INITIALIZATION failed\n");
        return XST_FAILURE;
      }



  OLEDrgb_Clear(&pmodOLEDrgb_inst);
  OLEDrgb_SetFontColor(&pmodOLEDrgb_inst,OLEDrgb_BuildRGB(220,20,60));
  OLEDrgb_SetCursor(&pmodOLEDrgb_inst, 0, 0);
  OLEDrgb_PutString(&pmodOLEDrgb_inst, "RC:");
  OLEDrgb_SetCursor(&pmodOLEDrgb_inst, 6, 0);
  OLEDrgb_PutString(&pmodOLEDrgb_inst, "DC:");
  OLEDrgb_SetCursor(&pmodOLEDrgb_inst, 0, 2);
  OLEDrgb_PutString(&pmodOLEDrgb_inst, "kp:");
  OLEDrgb_SetCursor(&pmodOLEDrgb_inst, 4, 2);
  OLEDrgb_PutString(&pmodOLEDrgb_inst, "ki:");
  OLEDrgb_SetCursor(&pmodOLEDrgb_inst, 9, 2);
  OLEDrgb_PutString(&pmodOLEDrgb_inst, "kd:");
  OLEDrgb_SetCursor(&pmodOLEDrgb_inst, 0, 5);
  OLEDrgb_PutString(&pmodOLEDrgb_inst, "DRPM:");
  OLEDrgb_SetCursor(&pmodOLEDrgb_inst, 0, 7);
  OLEDrgb_PutString(&pmodOLEDrgb_inst, "ARPM:");

  return XST_SUCCESS;
}

int Initialize_GPIOS()
{
  int status;
  // initialize the GPIO instances
  status = XGpio_Initialize(&MOTORSENSOR_inst, GPIO_DIRSEN_DEVICE_ID);
  if (status != XST_SUCCESS)
    {
      xil_printf("GPIO 2 failed\n");
      return XST_FAILURE;
    }
  XGpio_SetDataDirection(&MOTORSENSOR_inst, GPIO_DIR_OUTPUT_CHANNEL, 0);
  XGpio_SetDataDirection(&MOTORSENSOR_inst, GPIO_SEN_INPUT_CHANNEL, 1);

  // initialize the GPIO instances
  status = XGpio_Initialize(&LED_inst, GPIO_LED_DEVICE_ID);
  if (status != XST_SUCCESS)
    {
      xil_printf("GPIO 1 failed\n");
      return XST_FAILURE;
    }
  XGpio_SetDataDirection(&LED_inst, GPIO_LED_OUTPUT_CHANNEL, 0);

  // initialize the GPIO instances
  status = XGpio_Initialize(&SWITCHBUTTON_inst, GPIO_SWBUT_DEVICE_ID);
  if (status != XST_SUCCESS)
    {
      xil_printf("GPIO 0 failed\n");
      return XST_FAILURE;
    }
  XGpio_SetDataDirection(&SWITCHBUTTON_inst, GPIO_BUT_INPUT_CHANNEL, 0x1F);
  XGpio_SetDataDirection(&SWITCHBUTTON_inst, GPIO_SW_INPUT_CHANNEL, 0xFFFF);

  return XST_SUCCESS;
}

int Initialize_PWM(void)
{
  uint32_t status;        //Status from Xilinx Library calls

  //Initialize the PWM
  status = PWM_Initialize(&AXITimerInst1, AXI_TIMER_1_DEVICE_ID,false, AXI_CLOCK_FREQ_HZ);
  if(status != XST_SUCCESS)
    {
      xil_printf("Failed to initialize PWM\n");
      return XST_FAILURE;
    }

  //Start the PWM
  status =  PWM_Start(&AXITimerInst1);
  if(status != XST_SUCCESS)
    {
      xil_printf("\nFailed to start the PWM");
      return XST_FAILURE;
    }
  return XST_SUCCESS;
}

portBASE_TYPE Initiaize_INTERRUPTS()
{
  portBASE_TYPE xStatus;
  //Installing and Enabling Interrupt Handlers
  xStatus = xPortInstallInterruptHandler( GPIO_SWBUT_INTERRUPT_ID, PERIPHERAL_Handler, NULL );
  if (xStatus != pdPASS)
    {
      xil_printf("Connection Failed For PERIPHERAL_Handler to INTC\n");
      return pdFAIL;

    }

  vPortEnableInterrupt(GPIO_SWBUT_INTERRUPT_ID);
  //Installing and Enabling Interrupt Handlers
  xStatus = xPortInstallInterruptHandler( GPIO_SEN_INTERRUPT_ID, PULSE_Handler, NULL );
  if (xStatus != pdPASS)
    {
      xil_printf("Connection Failed For PULSE_Handler to INTC\n");
      return pdFAIL;

    }

  vPortEnableInterrupt(GPIO_SEN_INTERRUPT_ID);
  //Installing and Enabling Interrupt Handlers
  xStatus = xPortInstallInterruptHandler( AXI_TIMER_2_INTERRUPT_ID, SECONDS_Handler, NULL );
  if (xStatus != pdPASS)
    {
      xil_printf("Connection Failed For SECONDS_Handler to INTC\n");
      return pdFAIL;

    }

  vPortEnableInterrupt(AXI_TIMER_2_INTERRUPT_ID);
  //Installing and Enabling Interrupt Handlers
  xStatus = xPortInstallInterruptHandler( WATCHDOG_TIMER_ID, WATCHDOG_Handler, NULL );
   if (xStatus != pdPASS)
     {
       xil_printf("Connection Failed For WATCHDOG_Handler to INTC\n");
       return pdFAIL;

     }

   vPortEnableInterrupt(WATCHDOG_TIMER_ID);

   //Enabling global interrupt handlers for XGpio
  XGpio_InterruptGlobalEnable(&SWITCHBUTTON_inst);
  XGpio_InterruptEnable(&SWITCHBUTTON_inst, SWITCHES_ENABLE_MASK);
  XGpio_InterruptGlobalEnable(&MOTORSENSOR_inst);
  XGpio_InterruptEnable(&MOTORSENSOR_inst, 0xffff);

  configASSERT( ( xStatus == pdPASS ) );

  return pdPASS;
}


int AXI_Timer_initialize(void)
{

  uint32_t 	status;				// status from Xilinx Lib calls
  u32		ctlsts;
  u32		ctlsts1;// control/status register or mask
  u32		ctlsts2;

  status = XTmrCtr_Initialize(&AXITimerInst,AXI_TIMER_0_DEVICE_ID);
  if (status != XST_SUCCESS) {
      xil_printf("AXI Timer INITIALIZATION Failed\n");
      return XST_FAILURE;
  }
  status = XTmrCtr_Initialize(&AXITimerInst1,AXI_TIMER_1_DEVICE_ID);
  if (status != XST_SUCCESS) {
      xil_printf("AXI Timer 1 INITIALIZATION Failed\n");
      return XST_FAILURE;
  }

  status = XTmrCtr_Initialize(&AXITimerInst2,AXI_TIMER_2_DEVICE_ID);
  if (status != XST_SUCCESS) {
      xil_printf("AXI Timer 2 INITIALIZATION Failed\n");
      return XST_FAILURE;
  }
  status = XTmrCtr_SelfTest(&AXITimerInst, TmrCtrNumber);
  if (status != XST_SUCCESS) {
      return XST_FAILURE;
  }
  status = XTmrCtr_SelfTest(&AXITimerInst1, TmrCtrNumber1);
  if (status != XST_SUCCESS) {
      return XST_FAILURE;
  }
  status = XTmrCtr_SelfTest(&AXITimerInst2, TmrCtrNumber2);
  if (status != XST_SUCCESS) {
      return XST_FAILURE;
  }
  ctlsts = XTC_CSR_AUTO_RELOAD_MASK | XTC_CSR_EXT_GENERATE_MASK | XTC_CSR_LOAD_MASK |XTC_CSR_DOWN_COUNT_MASK ;
  XTmrCtr_SetControlStatusReg(AXI_TIMER_0_BASEADDR, TmrCtrNumber,ctlsts);
  ctlsts1 = XTC_CSR_AUTO_RELOAD_MASK | XTC_CSR_EXT_GENERATE_MASK | XTC_CSR_LOAD_MASK |XTC_CSR_DOWN_COUNT_MASK ;
  XTmrCtr_SetControlStatusReg(AXI_TIMER_1_BASEADDR, TmrCtrNumber1,ctlsts1);
  ctlsts2 = XTC_CSR_AUTO_RELOAD_MASK | XTC_CSR_LOAD_MASK |XTC_CSR_DOWN_COUNT_MASK |XTC_CSR_ENABLE_INT_MASK ;
  XTmrCtr_SetControlStatusReg(AXI_TIMER_2_BASEADDR, TmrCtrNumber2,ctlsts2);

  //Set the value that is loaded into the timer counter and cause it to be loaded into the timer counter
  // Frquency is increased to 400 kHz from 4 Khz to see if hardware can detect the pwm signal
  XTmrCtr_SetLoadReg(AXI_TIMER_0_BASEADDR, TmrCtrNumber, 24998);
  XTmrCtr_LoadTimerCounterReg(AXI_TIMER_0_BASEADDR, TmrCtrNumber);
  ctlsts = XTmrCtr_GetControlStatusReg(AXI_TIMER_0_BASEADDR, TmrCtrNumber);
  ctlsts &= (~XTC_CSR_LOAD_MASK);
  XTmrCtr_SetControlStatusReg(AXI_TIMER_0_BASEADDR, TmrCtrNumber, ctlsts);

  ctlsts = XTmrCtr_GetControlStatusReg(AXI_TIMER_0_BASEADDR, TmrCtrNumber);
  ctlsts |= XTC_CSR_ENABLE_TMR_MASK;
  XTmrCtr_SetControlStatusReg(AXI_TIMER_0_BASEADDR, TmrCtrNumber, ctlsts);


  XTmrCtr_SetLoadReg(AXI_TIMER_1_BASEADDR, TmrCtrNumber1, 24998);
  XTmrCtr_LoadTimerCounterReg(AXI_TIMER_1_BASEADDR, TmrCtrNumber1);
  ctlsts1 = XTmrCtr_GetControlStatusReg(AXI_TIMER_1_BASEADDR, TmrCtrNumber1);
  ctlsts1 &= (~XTC_CSR_LOAD_MASK);
  XTmrCtr_SetControlStatusReg(AXI_TIMER_1_BASEADDR, TmrCtrNumber1, ctlsts1);

  ctlsts1 = XTmrCtr_GetControlStatusReg(AXI_TIMER_1_BASEADDR, TmrCtrNumber1);
  ctlsts1 |= XTC_CSR_ENABLE_TMR_MASK;
  XTmrCtr_SetControlStatusReg(AXI_TIMER_1_BASEADDR, TmrCtrNumber1, ctlsts1);

  XTmrCtr_SetLoadReg(AXI_TIMER_2_BASEADDR, TmrCtrNumber2, 99999998);
  XTmrCtr_LoadTimerCounterReg(AXI_TIMER_2_BASEADDR, TmrCtrNumber2);
  ctlsts2 = XTmrCtr_GetControlStatusReg(AXI_TIMER_2_BASEADDR, TmrCtrNumber2);
  ctlsts2 &= (~XTC_CSR_LOAD_MASK);
  XTmrCtr_SetControlStatusReg(AXI_TIMER_2_BASEADDR, TmrCtrNumber2, ctlsts2);

  ctlsts2 = XTmrCtr_GetControlStatusReg(AXI_TIMER_2_BASEADDR, TmrCtrNumber2);
  ctlsts2 |= XTC_CSR_ENABLE_TMR_MASK;
  XTmrCtr_SetControlStatusReg(AXI_TIMER_2_BASEADDR, TmrCtrNumber2, ctlsts2);

  XTmrCtr_Enable(AXI_TIMER_0_BASEADDR, TmrCtrNumber);
  XTmrCtr_Enable(AXI_TIMER_1_BASEADDR, TmrCtrNumber1);
  XTmrCtr_Enable(AXI_TIMER_2_BASEADDR, TmrCtrNumber2);

  return XST_SUCCESS;

}

/**************************************************Helper Functions****************************************/
//This function is used to check if Button is pressed if yes it returns 1 or else it returns 0
int isbutton_pressed(enum _GPIO_btns btnslct)
{
  u8  msk,btns;
  u32 val;
  val = XGpio_DiscreteRead(&SWITCHBUTTON_inst,GPIO_BUT_INPUT_CHANNEL);
  btns = (val & GPIO_ALLBTNS_MASK);

  switch (btnslct)
  {
    case BTNR:

      msk = GPIO_BTNR_MASK;

      break;
    case BTNL:

      msk = GPIO_BTNL_MASK;

      break;
    case BTND:

      msk = GPIO_BTND_MASK;

      break;
    case BTNU:

      msk = GPIO_BTNU_MASK;

      break;
    case BTNC:

      msk = GPIO_BTNC_MASK;

      break;

    default: msk = 0;
    break;

  }
  return (msk == btns)? 1 : 0;
}

//GET_SWITCHES function to read switches
u16 GET_SWITCHES(void)
{
  u16 switches;
  switches = XGpio_DiscreteRead(&SWITCHBUTTON_inst,GPIO_SW_INPUT_CHANNEL);
  xil_printf("%x\n",switches);
  return (u16) switches;
}

//SET_LED function to write the specific led
void SET_LED(uint16_t ledval)
{
  u32 val;
  val = ledval & GPIO_LED_MASK;
  XGpio_DiscreteWrite(&LED_inst,GPIO_LED_OUTPUT_CHANNEL,val);
}

void PMDIO_putnum(PmodOLEDrgb* InstancePtr, int32_t num, int32_t radix)
{
  char  buf[16];

  PMDIO_itoa(num, buf, radix);
  OLEDrgb_PutString(InstancePtr,buf);

  return;
}

void PMDIO_puthex(PmodOLEDrgb* InstancePtr, uint32_t num)
{
  char  buf[9];
  int32_t   cnt;
  char  *ptr;
  int32_t  digit;

  ptr = buf;
  for (cnt = 7; cnt >= 0; cnt--) {
      digit = (num >> (cnt * 4)) & 0xF;

      if (digit <= 9)
	{
	  *ptr++ = (char) ('0' + digit);
	}
      else
	{
	  *ptr++ = (char) ('a' - 10 + digit);
	}
  }

  *ptr = (char) 0;
  OLEDrgb_PutString(InstancePtr,buf);

  return;
}

void PMDIO_itoa(int32_t value, char *string, int32_t radix)
{
  char tmp[33];
  char *tp = tmp;
  int32_t i;
  uint32_t v;
  int32_t  sign;
  char *sp;

  if (radix > 36 || radix <= 1)
    {
      return;
    }

  sign = ((10 == radix) && (value < 0));
  if (sign)
    {
      v = -value;
    }
  else
    {
      v = (uint32_t) value;
    }

  while (v || tp == tmp)
    {
      i = v % radix;
      v = v / radix;
      if (i < 10)
	{
	  *tp++ = i+'0';
	}
      else
	{
	  *tp++ = i + 'a' - 10;
	}
    }
  sp = string;

  if (sign)
    *sp++ = '-';

  while (tp > tmp)
    *sp++ = *--tp;
  *sp = 0;

  return;
}
